; ====================
; A number of helpful functions to check your designs, export to CAD,
; update your design in CAD, etc.
; ====================
#use-added-syntax(jitx)
defpackage helpers :
  import core
  import jitx
  import jitx/commands
  import ocdb/utils/checks
  import ocdb/utils/generic-components
  import rules

; ============
; setup-design
; ============
public defn setup-design (name:String, board:Board
                          --
                          rules:Rules = fs-tech-rules
                          vendors:Tuple<String|AuthorizedVendor> = ocdb/utils/design-vars/APPROVED-DISTRIBUTOR-LIST
                          quantity:Int = ocdb/utils/design-vars/DESIGN-QUANTITY) :
  set-current-design(name)
  set-board(board)
  set-rules(rules)
  set-bom-vendors(vendors)
  set-bom-design-quantity(quantity)
  set-use-layout-groups()
  ; set-bom-columns([
  ;   BOMColumn(BOMFieldDescription, "Comment", 10.0)
  ;   BOMColumn(BOMFieldInsts, "Designator", 10.0)
  ;   BOMColumn(BOMFieldSKU, "JLCPCB Part#", 10.0)
  ;   BOMColumn(BOMFieldMPN, "MPN", 10.0)
  ;   BOMColumn(BOMFieldDescription, "Description", 20.0)
  ; ])

; =====================
; Run the design checks
; =====================
public defn run-check-on-design (circuit:Instantiable) :
  val main-module = ocdb/utils/generator-utils/run-final-passes(circuit) ; Analyze design with a pass
  set-main-module(main-module) ; Treat the provided module as a design, and compile it.
  run-checks("checks.txt")

; ====================
; Actual Export design
; ====================
public defn export-to-cad () :
  export-cad()


; flex export with extra property handling
public defn export-cad-flex () :
  export-cad([
    "vendor_part_numbers.lcsc" => "LCSC"
  ])

; ====================
; Export design to CAD
; ====================
public defn export-design () :
  set-export-board?(true)
  export-to-cad()

; ===================================
; Update CAD, keeping layout progress
; ===================================
public defn update-design () :
  set-export-board?(false)
  export-to-cad()

; =================
; Export BOM to tsv
; =================
public defn export-bill-of-materials () :
  export-bom()


; =================
; User functions
; =================
public val bga-net-class = NetClass(`BGA, [`min-trace => 0.075, `min-space => 0.065])

; given a module and a pin that exists within that module, find the named net which that pin is connected to
public defn get-named-net (my-module: Instantiable|Self, my-pin:JITXObject) -> Net|False :
  ; for every connected item in the module, check if any of its pins are the pins we're looking for. If so, look at every net that pin is connected to, and return the first named net
  all-connected-items(my-module) $> find!{contains?{component-pins(_), my-pin}, _}
                                           $> find!{{ref?(_) is Ref}, nets(_)}

public defn apply-netclass-to-pins (my-module: Instantiable|Self, my-inst:JITXObject -- nc:NetClass = bga-net-class) :
  inside pcb-module :
    eval-when true : ; PROPAGATION-FINISHED :
      for my-pin in pins(my-inst) do :
        println("Pin (%_)" % [ref(my-pin)])
        if connected?(my-pin) :
          val my-net = get-named-net(my-module, my-pin)
          match(my-net:Net) :
            println("Info: Applying net-class to net (%_) connected to pin %_"  % [ref(my-net) ref(my-pin)])
            property(my-net.net-class) = nc
          else :
            println("Warning: No good net connected to pin %_"  % [ref(my-pin)])
        else :
          println("Warning: No nets connected to pin %_"  % [ref(my-pin)])
