; Generated by JITX 2.21.0-rc.3
#use-added-syntax(jitx)
defpackage main :
  import core
  import collections
  import math
  import lang-utils
  import jitx
  import jitx/commands

  import ocdb/utils/generic-components
  import ocdb/utils/box-symbol
  import ocdb/utils/bundles
  import ocdb/utils/property-structs
  import ocdb/utils/generator-utils
  import ocdb/utils/design-vars

  import helpers
  import rules
  import bundles
  import system

  import flex

MIN-PKG = "0201"
DESIGN-QUANTITY = 10
; max_height = 1.5
; DENSITY-LEVEL = 
set-rules(my-std-rules)

; Define the shape/size of the board
val x-off = 17.270
val y-off = -15.110
val x-but-off =  2.050
val y-but-off = 10.750

val board-shape = loc(x-off, y-off) * PolygonWithArcs([
                   Point( -4.770,   5.610),
                   Point(-31.020,   5.610),
                   Point(-31.020,  24.610),
                   Point( -3.520,  24.610),
                   Point( -3.520,   7.110),
                   Arc(Point(-3.770, 6.110), 1.000, 90.00, 90.00)]); Rectangle(26.0, 19.0)

val signal-shape = loc(x-off, y-off) * PolygonWithArcs([
                   Point( -4.770,   5.610),
                   Point(-31.020,   5.610),
                   Point(-31.020,  24.610),
                   Point( -3.520,  24.610),
                   Point( -3.520,   7.110),
                   Arc(Point(-3.770, 6.110), 1.000, 90.00, 90.00)]) ; Rectangle(26.0, 19.0)


public pcb-module board-io :
  port system-io : system-io
  pin VDD ; some vdd's
  pin VDD1P8
  pin GND

  public inst codec     : DA7212-01UM2/module
  public inst qsensor   : LSM6DSV16BX/module
  public inst button    : EVPBB4A9B000/component[3]
  public inst hapdrv    : DRV2605YZFR/module

  net (GND codec.GND hapdrv.GND qsensor.GND)
  net (VDD codec.VDDSYS hapdrv.VDD qsensor.GND)
  net (VDD1P8 qsensor.VDD)

  require codec-pdm : PDM from codec ; does this go away with a port?
  net (system-io.codec-pdm codec-pdm)
  val i2c-codec-pullups = add-open-drain-pullups(codec.i2c, VDD)
  net (system-io.codec-i2c codec.i2c)

  require qsen-i3c : i3c from qsensor
  net (system-io.qsen-i3c qsen-i3c)
  val i2c-qsens-pullups = add-open-drain-pullups(qsen-i3c, VDD)
  ; since there is ambiguity on which interface is being used
  ; need to add some no-pop resistors to preserve the ability
  ; to switch interfaces post-fabrication
  inst rs-sda : chip-resistor(0.0)
  inst rs-scl : chip-resistor(0.0)
  dnp(rs-sda)
  dnp(rs-scl)
  net (rs-sda.p[1] qsen-i3c.sda)
  net (rs-scl.p[1] qsen-i3c.scl)
  net (system-io.qsen-spi.sdo rs-sda.p[2])
  net (system-io.qsen-spi.sck rs-scl.p[2])
  net (system-io.qsen-spi.sdi qsensor.imu.SDO_SA0)
  net (system-io.qsen-spi.cs  qsensor.imu.CS     )

  net (system-io.haptic-intf hapdrv.intf)

  for i in 0 to 3 do :
    net (system-io.button-io[i].gpio button[i].A button[i].A1)
    net (GND button[i].B button[i].B1)

  schematic-group(self) = board-io

; Module to run as a design
public pcb-module beeper-design :
  port flex : flex-signals

  ; let's instance all of the major elements of the design at the top level
  inst flex-conn : beeper-connector(main-board)
  ; place(flex-conn) at loc(19.0, 7.00) on Top
  inst board-io  : board-io
  inst mcu       : DA14705-00000HZ2/module
  inst wpwr      : BQ51003YFPR/module
  ; setup some nets by default
  net VDD1P8  ()
  net VDD3P0  ()
  net VDDSYS  ()
  net VLED    ()
  net GND     ()

  val supply-nets = [VDD1P8 VDD3P0 VDDSYS VLED]
  ; connect nets to pins of the mcu module
  net (VDD1P8  mcu.V18)
  net (VDD3P0  mcu.V30)
  net (VDDSYS  mcu.VSYS)
  net (VLED    mcu.VLED)

  net (mcu.VBUSp wpwr.VBUSp)

  ; connect all of our grounds
  net (GND mcu.GND wpwr.GND board-io.GND)

  ; connect the power supplies at the top level for those components
  net (VDDSYS wpwr.VBUS board-io.VDD)
  net (VDD1P8 board-io.VDD1P8)

  ; connect i2c from codec to mcu
  net (board-io.system-io.codec-i2c mcu.codec-i2c)

  ; not sure if this is supposed to be SPI or I3C or both?
   ; i3c interface
  net (board-io.system-io.qsen-i3c mcu.qsen-i3c)

 ; if SPI then uncomment the following lines
  ; require qsen-spi : spi([SPI-SDO SPI-SDI SPI-CS]) from qsensor
  net (board-io.system-io.qsen-spi mcu.qsen-spi)

  ; now connect mcu to haptic driver
  net (board-io.system-io.haptic-intf mcu.haptic-intf)

  ; connect control/status pins to wireless power chip
  net (mcu.WPWR-CTRL wpwr.CMD)

  net (flex-conn.c.VDDMIC   board-io.codec.MICBIAS       )
  net (flex-conn.c.VDDVAD   VDD3P0                       )
  net (flex-conn.c.VDDLED   VLED                         )
  net (flex-conn.c.GND      GND                          )
  net (flex-conn.c.MICPDM   board-io.system-io.codec-pdm )
  net (flex-conn.c.LEDR     mcu.LED[0]                   )
  net (flex-conn.c.LEDG     mcu.LED[1]                   )
  net (flex-conn.c.LEDB     mcu.LED[2]                   )
  net (flex-conn.c.SPKP     board-io.codec.codec.SP_P   )
  net (flex-conn.c.SPKN     board-io.codec.codec.SP_N   )
  net (flex-conn.c.VADOUT   mcu.VADOUT                   )

  net (flex-conn.c flex)

  ; if we want testpoints on the power supplies we can uncomment the following line
  ; for p in [mcu.V12  mcu.V14 mcu.V18  mcu.V18F mcu.V18P mcu.V30 mcu.VBAT mcu.VBUS mcu.VSYS] do :
  ;   add-testpoint([p], gen-testpad(0.5))


  ; buttons (3) and placed per the mechanical design (subject to change)
  net (board-io.system-io.button-io mcu.button-io)

  val x-delta = 10.000
  for i in 0 to 3 do :
    place(board-io.button[i]) at loc(-31.020 + x-off + x-but-off + to-double(i) * 10.000,   5.610 + y-off + y-but-off, 90.0) on Top

  ; let's make prettier schematics
  symbol(GND) = ocdb/utils/symbols/ground-sym
  for n in supply-nets do :
    symbol(n) = ocdb/utils/symbols/altium-power-bar-sym

  ; power planes (let's assume 4 layers for now...)
  geom(GND) :
    copper-pour(LayerIndex(1), isolate = 0.1, rank = 1) = signal-shape
  geom(VDDSYS) :
    copper-pour(LayerIndex(2), isolate = 0.1, rank = 1) = signal-shape
  
  schematic-group(self) = main-board
  layout-group(self) = main-board

pcb-module top-level :
  inst m : beeper-design
  inst f : beeper-flex

  net (m.flex f.main)

; Set the design name     - a directory with this name will be generated under the "designs" directory
;     the board           - a Board object
;     [optional] rules    - the PCB design rules (if not given default rules will be used)
;     [optional] vendors  - Strings or AuthorizedVendors (if not give default vendors will be used)
;     [optional] quantity - Minimum stock quantity the vendor should carry (if not give default quantity will be used)

setup-design(
  ; "beeper-system", ; 
  "beeper-design"
  ocdb/utils/defaults/default-board(ocdb/manufacturers/stackups/bay-area-circuits-4-layer-62-mil, board-shape)
  quantity = DESIGN-QUANTITY
)

; Set the schematic sheet size
set-paper(ANSI-B)

; Set the top level module (the module to be compile into a schematic and PCB)
; set-main-module(top-level)
set-main-module(beeper-design)

; View the results
view-schematic()
; view-board()
view-design-explorer()
