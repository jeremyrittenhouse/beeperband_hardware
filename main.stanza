; Generated by JITX 2.21.0-rc.3
#use-added-syntax(jitx)
defpackage main :
  import core
  import collections
  import math
  import lang-utils
  import jitx
  import jitx/commands

  import ocdb/utils/generic-components
  import ocdb/utils/box-symbol
  import ocdb/utils/bundles
  import ocdb/utils/property-structs
  import ocdb/utils/generator-utils
  import ocdb/utils/design-vars

  import helpers
  import rules
  import bundles


MIN-PKG = "0201"
DESIGN-QUANTITY = 10
; max_height = 1.5
; DENSITY-LEVEL = 
set-rules(my-std-rules)

; Define the shape/size of the board
val x-off = 17.270
val y-off = -15.110
val x-but-off =  2.050
val y-but-off = 10.750
val board-shape = PolygonWithArcs([
                   Point( -4.770 + x-off,   5.610 + y-off),
                   Point(-31.020 + x-off,   5.610 + y-off),
                   Point(-31.020 + x-off,  24.610 + y-off),
                   Point( -3.520 + x-off,  24.610 + y-off),
                   Point( -3.520 + x-off,   7.110 + y-off),
                   Arc(Point(-3.770 + x-off, 6.110 + y-off), 1.000, 90.00, 90.00)]) ; Rectangle(26.0, 19.0)

val signal-shape = PolygonWithArcs([
                   Point( -4.770 + x-off,   5.610 + y-off),
                   Point(-31.020 + x-off,   5.610 + y-off),
                   Point(-31.020 + x-off,  24.610 + y-off),
                   Point( -3.520 + x-off,  24.610 + y-off),
                   Point( -3.520 + x-off,   7.110 + y-off),
                   Arc(Point(-3.770 + x-off, 6.110 + y-off), 1.000, 90.00, 90.00)]) ; Rectangle(26.0, 19.0)


; Module to run as a design
pcb-module beeper-design :

  ; let's instance all of the major elements of the design at the top level
  inst mcu     : DA14705/module
  inst mem     : AT25FF321A-UUN-T/module
  inst wpwr    : BQ51003YFPR/module
  inst codec   : DA7212-01UM2/module
  inst qsensor : LSM6DSV16BX/module
  ; inst vad-mic : PMM-3738-VM1000-R/module
  inst button  : EVPBB4A9B000/component[3]
  inst hap-drv : DRV2605YZFR/module
  
  ; setup some nets by default
  net VDD1P2  ()
  net VDD1P4  ()
  net VDD1P8  ()
  net VDD1P8F ()
  net VDD1P8P ()
  net VDD3P0  ()
  net VDDBAT  ()
  net VDDBUS  ()
  net VDDSYS  ()

  val supply-nets = [VDD1P2 VDD1P4 VDD1P8 VDD1P8F VDD1P8P VDD3P0 VDDBAT VDDBUS VDDSYS]
  ; connect nets to pins of the mcu module
  net (VDD1P2  mcu.V12)
  net (VDD1P4  mcu.V14)
  net (VDD1P8  mcu.V18)
  net (VDD1P8F mcu.V18F)
  net (VDD1P8P mcu.V18P)
  net (VDD3P0  mcu.V30)
  net (VDDBAT  mcu.VBAT)
  net (VDDBUS  mcu.VBUS)
  net (VDDSYS  mcu.VSYS)

  net (mcu.VBUSp wpwr.VBUSp)
  ; connect quad spi from memory to mcu
  require mem-qspi : quad-spi from mem.m
  require mcu-qspi : quad-spi from mcu.mcu
  net (mem-qspi mcu-qspi)

  ; connect i2c from codec to mcu
  require codec-i2c:i2c from codec
  require mcu-codec-i2c:i2c from mcu.mcu
  net (codec-i2c mcu-codec-i2c)
  val i2c-codec-pullups = add-open-drain-pullups(mcu-codec-i2c, VDDSYS)

  ; not sure if this is supposed to be SPI or I3C?
  ; if SPI then uncomment the following lines
  ; require qsen-spi : spi-w-en from qsensor
  ; require mcu-spi : spi-w-en from mcu.mcu
  ; net (qsen-spi mcu-spi)
  ; i3c interface
  require qsen-i3c : i3c from qsensor
  require mcu-i3c : i3c from mcu.mcu
  net (qsen-i3c mcu-i3c)
  val i2c-qsens-pullups = add-open-drain-pullups(mcu-i3c, VDDSYS)

  ; now connect i2c for haptic driver
  require drv-i2c : i2c from hap-drv
  require mcu-hap-i2c : i2c from mcu.mcu
  net (drv-i2c mcu-hap-i2c)
  val i2c-hap-pullups = add-open-drain-pullups(mcu-hap-i2c, VDDSYS)

  ; connect misc pins on haptic driver from whichever mcu pins make sense
  require mcu-hap : gpio[2] from mcu.mcu
  net (hap-drv.EN mcu-hap[0].gpio)
  net (hap-drv.IN_TRIG mcu-hap[1].gpio)

  ; haptic output header (for now)
  inst haptic : pin-header(2, 1.00)
  component-status(haptic) :
    bom-status = NotInBOM

  net (haptic.p[1] hap-drv.OUT+)
  net (haptic.p[2] hap-drv.OUT-)

  ; connect control/status pins to wireless power chip
  require mcu-wpwr : gpio[4] from mcu.mcu
  net (wpwr.EN1 mcu-wpwr[0].gpio)
  net (wpwr.EN2 mcu-wpwr[1].gpio)
  net (wpwr.nCHG mcu-wpwr[2].gpio)
  net (wpwr.CTRL mcu-wpwr[3].gpio)

  ; if we want testpoints on the power supplies we can uncomment the following line
  ; for p in [mcu.V12  mcu.V14 mcu.V18  mcu.V18F mcu.V18P mcu.V30 mcu.VBAT mcu.VBUS mcu.VSYS] do :
  ;   add-testpoint([p], gen-testpad(0.5))

  ; connect all of our grounds
  net GND (mcu.GND mem.m.GND wpwr.GND codec.pwr1p8.gnd codec.pwrsys.gnd hap-drv.GND qsensor.GND)
  ; vad-mic.GND

  ; connect the power supplies at the top level for those components
  net (VDDSYS mem.m.Vcc wpwr.VBUS codec.pwrsys.vdd hap-drv.VDD)
  net (VDD1P8 codec.pwr1p8.vdd qsensor.VDD)
  ; vad-mic.VDD 

  ; connect VAD microphone -> just a single analog connection
  ;net (vad-mic.OUT mcu.mcu.VAD)

  ; buttons (3) and placed per the mechanical design (subject to change)
  require mcu-but : gpio[3] from mcu.mcu
  for i in 0 to 3 do :
    net (mcu-but[i].gpio button[i].A button[i].A1)
    net (GND button[i].B button[i].B1)
  val x-delta = 10.000
  for i in 0 to 3 do :
    place(button[i]) at loc(-31.020 + x-off + x-but-off + to-double(i) * 10.000,   5.610 + y-off + y-but-off, 90.0) on Top

  ; let's make prettier schematics
  symbol(GND) = ocdb/utils/symbols/ground-sym
  for n_ in supply-nets do :
    symbol(n_) = ocdb/utils/symbols/supply-sym

  ; power planes (let's assume 4 layers for now...)
  geom(GND):
    copper-pour(LayerIndex(1), isolate = 0.1, rank = 1) = signal-shape
  geom(VDDSYS) :
    copper-pour(LayerIndex(2), isolate = 0.1, rank = 1) = signal-shape

  ; layer(Cutout()) = Line(0.2, [Point(-31.02, 5.61), Point(-4.77000000000001, 5.61)])
  ; layer(Cutout()) = Line(0.2, [Point(-3.52000000000001, 7.11), Point(-3.52000000000001, 24.61)])
  ; layer(Cutout()) = Line(0.2, [Point(-4.77000000000001, 5.61), Point(-4.77000000000001, 6.11)])
  ; layer(Cutout()) = Line(0.2, [Point(-3.52000000000001, 24.61), Point(-31.02, 24.61)])
  ; layer(Cutout()) = Line(0.2, [Point(-31.02, 24.61), Point(-31.02, 5.61)])
  ; layer(Cutout()) = Line(0.2, [Point(-3.77000000000001, 7.11), Point(-3.52000000000001, 7.11)])
  ; layer(Cutout()) = Polyline(0.2, [Arc(-3.7699802613628, 6.10998026136275, 1.00001973883201, 179.998869081715, -89.9977381634326)])


; Set the design name     - a directory with this name will be generated under the "designs" directory
;     the board           - a Board object
;     [optional] rules    - the PCB design rules (if not given default rules will be used)
;     [optional] vendors  - Strings or AuthorizedVendors (if not give default vendors will be used)
;     [optional] quantity - Minimum stock quantity the vendor should carry (if not give default quantity will be used)
setup-design(
  "beeper-design",
  ocdb/utils/defaults/default-board(ocdb/manufacturers/stackups/bay-area-circuits-4-layer-62-mil, board-shape,)
  quantity = DESIGN-QUANTITY
)

; Set the schematic sheet size
set-paper(ANSI-B)

; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(beeper-design)

; View the results
view-schematic()
view-board()
; view-design-explorer()
